{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"Hearty_attiny10/","text":"ATtiny10 BASED HEARTY OBJECTIVE A wearable electronic heart-shaped pendant based on ATtiny10 that displays interesting patterns using 6 Charlieplexed LEDs . SCHEMATIC LAYOUT COMPLETED PCB CODE /* * hearty_attiny10.cpp * * Created: 19-01-2020 20:13:13 * Author : Naman */ # define F_CPU 1000000UL #include <avr/io.h> #include <util/delay.h> #include <avr/interrupt.h> void LED1 (), LED2 (), LED3 (), LED4 (), LED5 (), LED6 (); void alternate_led (); void all_blink (); void two_to_full (); void off_moving (); void half_blink (); void one_by_one (); int main ( void ) { /* Replace with your application code */ while ( 1 ) { alternate_led (); _delay_ms ( 50 ); all_blink (); off_moving (); half_blink (); one_by_one (); } } void LED1 () { DDRB |= 0b00000011 ; /* PB0 and PB1 as output */ DDRB &= 0b11111011 ; /* PB2 as input */ PORTB |= 0b00000001 ; /* PB0 high */ PORTB &= 0b11111101 ; /* PB1 low */ } void LED2 () { DDRB |= 0b00000110 ; /* PB0 and PB1 as output */ DDRB &= 0b11111110 ; /* PB2 as input */ PORTB |= 0b00000100 ; /* PB2 high */ PORTB &= 0b11111101 ; /* PB1 low */ } void LED3 () { DDRB |= 0b00000101 ; /* PB0 and PB2 as output */ DDRB &= 0b11111101 ; /* PB1 as input */ PORTB |= 0b00000001 ; /* PB0 high */ PORTB &= 0b11111011 ; /* PB2 low */ } void LED4 () { DDRB |= 0b00000011 ; /* PB1 and PB0 as output */ DDRB &= 0b11111011 ; /* PB2 as input */ PORTB |= 0b00000010 ; /* PB1 high */ PORTB &= 0b11111110 ; /* PB0 low */ } void LED5 () { DDRB |= 0b00000110 ; /* PB1 and PB2 as output */ DDRB &= 0b11111110 ; /* PB0 as input */ PORTB |= 0b00000010 ; /* PB1 high */ PORTB &= 0b11111011 ; /* PB2 low */ } void LED6 () { DDRB |= 0b00000101 ; /* PB0 and PB2 as output */ DDRB &= 0b11111101 ; /* PB1 as input */ PORTB |= 0b00000100 ; /* PB2 high */ PORTB &= 0b11111110 ; /* PB0 low */ } void alternate_led () { for ( int z = 0 ; z < 5 ; z ++ ) { for ( int j = 0 ; j < 5000 ; j ++ ) { LED1 (), LED3 (), LED5 (); } for ( int k = 0 ; k < 5000 ; k ++ ) { LED2 (), LED4 (), LED6 (); } } } void all_blink () { for ( int z = 0 ; z < 5 ; z ++ ) { for ( int i = 0 ; i < 5000 ; i ++ ) { LED1 (), LED2 (), LED3 (), LED4 (), LED5 (), LED6 (); } DDRB &= 0b11111000 ; /* ALL LEDS OFF*/ _delay_ms ( 100 ); } } void off_moving () { for ( int k = 0 ; k < 5 ; k ++ ) { int z = 1000 ; for ( int i = 0 ; i < z ; i ++ ) { LED2 (), LED3 (), LED4 (), LED5 (), LED6 (); } for ( int j = 0 ; j < z ; j ++ ) { LED1 (), LED3 (), LED4 (), LED5 (), LED6 (); } for ( int k = 0 ; k < z ; k ++ ) { LED1 (), LED2 (), LED4 (), LED5 (), LED6 (); } for ( int l = 0 ; l < z ; l ++ ) { LED1 (), LED2 (), LED3 (), LED5 (), LED6 (); } for ( int m = 0 ; m < z ; m ++ ) { LED1 (), LED2 (), LED3 (), LED4 (), LED6 (); } for ( int n = 0 ; n < z ; n ++ ) { LED1 (), LED2 (), LED3 (), LED4 (), LED5 (); } } } void half_blink () { for ( int k = 0 ; k < 10 ; k ++ ) { int z = 2000 ; for ( int i = 0 ; i < z ; i ++ ) { LED1 (), LED2 (), LED3 (); } for ( int j = 0 ; j < z ; j ++ ) { LED4 (), LED5 (), LED6 (); } } } void one_by_one () { for ( int k = 0 ; k < 2 ; k ++ ) { //int z = 6000; for ( int q = 0 ; q < 6000 ; q ++ ) { DDRB &= 0b11111000 ; /* ALL LEDS OFF*/ } for ( int i = 0 ; i < 12000 ; i ++ ) { LED1 (); } for ( int j = 0 ; j < 6000 ; j ++ ) { LED1 (), LED2 (); } for ( int k = 0 ; k < 4000 ; k ++ ) { LED1 (), LED2 (), LED3 (); } for ( int l = 0 ; l < 3000 ; l ++ ) { LED1 (), LED2 (), LED3 (), LED4 (); } for ( int m = 0 ; m < 2400 ; m ++ ) { LED1 (), LED2 (), LED3 (), LED4 (), LED5 (); } for ( int n = 0 ; n < 2000 ; n ++ ) { LED1 (), LED2 (), LED3 (), LED4 (), LED5 (), LED6 (); } for ( int i = 0 ; i < 5 ; i ++ ) { DDRB &= 0b11111000 ; /* ALL LEDS OFF*/ _delay_ms ( 100 ); for ( int p = 0 ; p < 500 ; p ++ ) { LED1 (), LED2 (), LED3 (), LED4 (), LED5 (), LED6 (); } //_delay_ms(100); } } }","title":"ATtiny10 Based Hearty"},{"location":"Hearty_attiny10/#attiny10-based-hearty","text":"","title":"ATtiny10 BASED HEARTY"},{"location":"Hearty_attiny10/#objective","text":"A wearable electronic heart-shaped pendant based on ATtiny10 that displays interesting patterns using 6 Charlieplexed LEDs .","title":"OBJECTIVE"},{"location":"Hearty_attiny10/#schematic","text":"","title":"SCHEMATIC"},{"location":"Hearty_attiny10/#layout","text":"","title":"LAYOUT"},{"location":"Hearty_attiny10/#completed-pcb","text":"","title":"COMPLETED PCB"},{"location":"Hearty_attiny10/#code","text":"/* * hearty_attiny10.cpp * * Created: 19-01-2020 20:13:13 * Author : Naman */ # define F_CPU 1000000UL #include <avr/io.h> #include <util/delay.h> #include <avr/interrupt.h> void LED1 (), LED2 (), LED3 (), LED4 (), LED5 (), LED6 (); void alternate_led (); void all_blink (); void two_to_full (); void off_moving (); void half_blink (); void one_by_one (); int main ( void ) { /* Replace with your application code */ while ( 1 ) { alternate_led (); _delay_ms ( 50 ); all_blink (); off_moving (); half_blink (); one_by_one (); } } void LED1 () { DDRB |= 0b00000011 ; /* PB0 and PB1 as output */ DDRB &= 0b11111011 ; /* PB2 as input */ PORTB |= 0b00000001 ; /* PB0 high */ PORTB &= 0b11111101 ; /* PB1 low */ } void LED2 () { DDRB |= 0b00000110 ; /* PB0 and PB1 as output */ DDRB &= 0b11111110 ; /* PB2 as input */ PORTB |= 0b00000100 ; /* PB2 high */ PORTB &= 0b11111101 ; /* PB1 low */ } void LED3 () { DDRB |= 0b00000101 ; /* PB0 and PB2 as output */ DDRB &= 0b11111101 ; /* PB1 as input */ PORTB |= 0b00000001 ; /* PB0 high */ PORTB &= 0b11111011 ; /* PB2 low */ } void LED4 () { DDRB |= 0b00000011 ; /* PB1 and PB0 as output */ DDRB &= 0b11111011 ; /* PB2 as input */ PORTB |= 0b00000010 ; /* PB1 high */ PORTB &= 0b11111110 ; /* PB0 low */ } void LED5 () { DDRB |= 0b00000110 ; /* PB1 and PB2 as output */ DDRB &= 0b11111110 ; /* PB0 as input */ PORTB |= 0b00000010 ; /* PB1 high */ PORTB &= 0b11111011 ; /* PB2 low */ } void LED6 () { DDRB |= 0b00000101 ; /* PB0 and PB2 as output */ DDRB &= 0b11111101 ; /* PB1 as input */ PORTB |= 0b00000100 ; /* PB2 high */ PORTB &= 0b11111110 ; /* PB0 low */ } void alternate_led () { for ( int z = 0 ; z < 5 ; z ++ ) { for ( int j = 0 ; j < 5000 ; j ++ ) { LED1 (), LED3 (), LED5 (); } for ( int k = 0 ; k < 5000 ; k ++ ) { LED2 (), LED4 (), LED6 (); } } } void all_blink () { for ( int z = 0 ; z < 5 ; z ++ ) { for ( int i = 0 ; i < 5000 ; i ++ ) { LED1 (), LED2 (), LED3 (), LED4 (), LED5 (), LED6 (); } DDRB &= 0b11111000 ; /* ALL LEDS OFF*/ _delay_ms ( 100 ); } } void off_moving () { for ( int k = 0 ; k < 5 ; k ++ ) { int z = 1000 ; for ( int i = 0 ; i < z ; i ++ ) { LED2 (), LED3 (), LED4 (), LED5 (), LED6 (); } for ( int j = 0 ; j < z ; j ++ ) { LED1 (), LED3 (), LED4 (), LED5 (), LED6 (); } for ( int k = 0 ; k < z ; k ++ ) { LED1 (), LED2 (), LED4 (), LED5 (), LED6 (); } for ( int l = 0 ; l < z ; l ++ ) { LED1 (), LED2 (), LED3 (), LED5 (), LED6 (); } for ( int m = 0 ; m < z ; m ++ ) { LED1 (), LED2 (), LED3 (), LED4 (), LED6 (); } for ( int n = 0 ; n < z ; n ++ ) { LED1 (), LED2 (), LED3 (), LED4 (), LED5 (); } } } void half_blink () { for ( int k = 0 ; k < 10 ; k ++ ) { int z = 2000 ; for ( int i = 0 ; i < z ; i ++ ) { LED1 (), LED2 (), LED3 (); } for ( int j = 0 ; j < z ; j ++ ) { LED4 (), LED5 (), LED6 (); } } } void one_by_one () { for ( int k = 0 ; k < 2 ; k ++ ) { //int z = 6000; for ( int q = 0 ; q < 6000 ; q ++ ) { DDRB &= 0b11111000 ; /* ALL LEDS OFF*/ } for ( int i = 0 ; i < 12000 ; i ++ ) { LED1 (); } for ( int j = 0 ; j < 6000 ; j ++ ) { LED1 (), LED2 (); } for ( int k = 0 ; k < 4000 ; k ++ ) { LED1 (), LED2 (), LED3 (); } for ( int l = 0 ; l < 3000 ; l ++ ) { LED1 (), LED2 (), LED3 (), LED4 (); } for ( int m = 0 ; m < 2400 ; m ++ ) { LED1 (), LED2 (), LED3 (), LED4 (), LED5 (); } for ( int n = 0 ; n < 2000 ; n ++ ) { LED1 (), LED2 (), LED3 (), LED4 (), LED5 (), LED6 (); } for ( int i = 0 ; i < 5 ; i ++ ) { DDRB &= 0b11111000 ; /* ALL LEDS OFF*/ _delay_ms ( 100 ); for ( int p = 0 ; p < 500 ; p ++ ) { LED1 (), LED2 (), LED3 (), LED4 (), LED5 (), LED6 (); } //_delay_ms(100); } } }","title":"CODE"},{"location":"boost_tiny45/","text":"BATTERY LEVEL MONITORING AND BOOST BASED ON ATtiny45 OBJECTIVE A boost converter along with auto power cut-off, with an indication for low battery is implemented using ATtiny45 microcontroller. The project was developed to help visually impaired students for carrying out science based optical bench experiments. SCHEMATIC LAYOUT COMPLETED PCB FULLY-CASED ...to be updated CODE #define feedback A3 #define btfd A1 #define buzzer 1 #define F_CPU 8000000UL #include <avr/io.h> #include <util/delay.h> #define max_pwm 128 // #define reqVol 930*0.25 //0.35V #define reqbattery 688 float reading = 0 ; float bttryvol = 0 ; void setup () { // put your setup code here, to run once: DDRB |= 0x01 ; //PB0 as output TCCR1 = ( 1 << CTC1 ) | ( 1 << PWM1A ) | ( 1 << COM1A0 ) | ( 1 << CS10 ); TCCR1 &= ~ (( 1 << CS13 ) | ( 1 << CS12 ) | ( 1 << CS11 ) | ( 1 << COM1A1 )); OCR1C = 0xFF ; //top = 255; OCR1A = 231 ; analogReference ( INTERNAL1V1 ); pinMode ( feedback , INPUT ); pinMode ( btfd , INPUT ); } void loop () { // put your main code here, to run repeatedly: bttryvol = 0 ; reading = 0 ; for ( int i = 1 ; i <= 256 ; i ++ ){ reading += analogRead ( feedback ); } reading /= 256 ; for ( int i = 1 ; i <= 256 ; i ++ ){ bttryvol += analogRead ( btfd ); } bttryvol /= 256 ; if ( bttryvol < reqbattery ){ TCCR1 &= ~ (( 1 << CS13 ) | ( 1 << CS12 ) | ( 1 << CS11 ) | ( 1 << CS10 ) | ( 1 << PWM1A ) | ( 1 << COM1A0 ) | ( 1 << COM1A1 )); pinMode ( buzzer , OUTPUT ); digitalWrite ( buzzer , HIGH ); _delay_ms ( 1000 ); digitalWrite ( buzzer , LOW ); while ( bttryvol < reqbattery ); } if ( reading < reqVol ){ OCR1A -- ; } if ( reading > reqVol ){ OCR1A ++ ; } if ( OCR1A <= max_pwm ){ OCR1A = max_pwm ; } } REFERENCES https://www.radiolocman.com/shem/schematics.html?di=582885","title":"Boost & Battery Monitoring"},{"location":"boost_tiny45/#battery-level-monitoring-and-boost-based-on-attiny45","text":"","title":"BATTERY LEVEL MONITORING AND BOOST BASED ON ATtiny45"},{"location":"boost_tiny45/#objective","text":"A boost converter along with auto power cut-off, with an indication for low battery is implemented using ATtiny45 microcontroller. The project was developed to help visually impaired students for carrying out science based optical bench experiments.","title":"OBJECTIVE"},{"location":"boost_tiny45/#schematic","text":"","title":"SCHEMATIC"},{"location":"boost_tiny45/#layout","text":"","title":"LAYOUT"},{"location":"boost_tiny45/#completed-pcb","text":"","title":"COMPLETED PCB"},{"location":"boost_tiny45/#fully-cased","text":"...to be updated","title":"FULLY-CASED"},{"location":"boost_tiny45/#code","text":"#define feedback A3 #define btfd A1 #define buzzer 1 #define F_CPU 8000000UL #include <avr/io.h> #include <util/delay.h> #define max_pwm 128 // #define reqVol 930*0.25 //0.35V #define reqbattery 688 float reading = 0 ; float bttryvol = 0 ; void setup () { // put your setup code here, to run once: DDRB |= 0x01 ; //PB0 as output TCCR1 = ( 1 << CTC1 ) | ( 1 << PWM1A ) | ( 1 << COM1A0 ) | ( 1 << CS10 ); TCCR1 &= ~ (( 1 << CS13 ) | ( 1 << CS12 ) | ( 1 << CS11 ) | ( 1 << COM1A1 )); OCR1C = 0xFF ; //top = 255; OCR1A = 231 ; analogReference ( INTERNAL1V1 ); pinMode ( feedback , INPUT ); pinMode ( btfd , INPUT ); } void loop () { // put your main code here, to run repeatedly: bttryvol = 0 ; reading = 0 ; for ( int i = 1 ; i <= 256 ; i ++ ){ reading += analogRead ( feedback ); } reading /= 256 ; for ( int i = 1 ; i <= 256 ; i ++ ){ bttryvol += analogRead ( btfd ); } bttryvol /= 256 ; if ( bttryvol < reqbattery ){ TCCR1 &= ~ (( 1 << CS13 ) | ( 1 << CS12 ) | ( 1 << CS11 ) | ( 1 << CS10 ) | ( 1 << PWM1A ) | ( 1 << COM1A0 ) | ( 1 << COM1A1 )); pinMode ( buzzer , OUTPUT ); digitalWrite ( buzzer , HIGH ); _delay_ms ( 1000 ); digitalWrite ( buzzer , LOW ); while ( bttryvol < reqbattery ); } if ( reading < reqVol ){ OCR1A -- ; } if ( reading > reqVol ){ OCR1A ++ ; } if ( OCR1A <= max_pwm ){ OCR1A = max_pwm ; } }","title":"CODE"},{"location":"boost_tiny45/#references","text":"https://www.radiolocman.com/shem/schematics.html?di=582885","title":"REFERENCES"},{"location":"wpt/","text":"MSP430 Project with Wireless Power Transfer OBJECTIVE A wirelessly powered artwork with warm-white leds and flexible string of leds inside a fish bowl, controlled using a MSP430 microcontroller. Power is transferred wirelessly using two coils, one used for transmitting and other for receiving. BLOCK DIAGRAM SCHEMATIC BOARD LAYOUT COMPLETED PCB WITH CANDLES CODE #include <msp430.h> #include <stdint.h> #define LED BIT1 // LED Strip -> P2.1 #define UP 1 //Increasing Brightness #define DOWN 0 //Decreasing Brightness #define BLINK 2 // For blink of leds /** * @brief * These settings are wrt enabling TIMER1 on Lunchbox **/ void register_settings_for_TIMER1 () { P2DIR |= LED ; // LED -> Output P2SEL |= LED ; // LED -> Select Timer Output TA1CCR0 = 255 ; // Set Timer0 PWM Period TA1CCTL1 = OUTMOD_7 ; // Set TA1.1 Waveform Mode - Clear on Compare, Set on Overflow TA1CCR1 = 0 ; // Set TA1.1 PWM duty cycle TA1CCTL0 = CCIE ; // CCR0 Enable Interrupt TA1CTL = TASSEL_2 + MC_1 ; // Timer Clock -> SMCLK, Mode -> Up } volatile int dir = UP ; volatile int count = 0 ; //for delay between change of dutycycle volatile int count2 = 0 ; //for delay between blinking volatile int count3 = 0 ; //for number of blinks between pwm /*brief entry point for TIMER1_interrupt vector */ #pragma vector = TIMER1_A0_VECTOR __interrupt void Timer_A ( void ){ count ++ ; if ( count > 100 ){ //enter if after 100 interrupts switch ( dir ){ case UP : TA1CCR1 = TA1CCR1 + 1 ; //increment CCR1 if ( TA1CCR1 > TA1CCR0 ){ dir = BLINK ; //change dir to BLINK count2 = 0 ; //initialize count2 count3 = 10 ; //initialize count3 } break ; case BLINK : count2 ++ ; // if(count2>10){ //do not change state of leds till count2 becomes 10 count3 -- ; //decrement no. of blinks if ( count3 > 0 ){ if ( TA1CCR1 == 0 ) TA1CCR1 = 255 ; //full brightness else { TA1CCR1 = 0 ; //zero brightness } } else { TA1CCR1 = 255 ; //full brightness dir = DOWN ; //change dir to decresing brightness } count2 = 0 ; } break ; case DOWN : TA1CCR1 = TA1CCR1 - 1 ; //decrement CCR1 if ( TA1CCR1 == 0 ){ dir = UP ; //change direction to increasing } break ; } count = 0 ; } } //@brief entry point for the code/ void main ( void ) { P1DIR |= 0xFF ; volatile unsigned int i ; // volatile to prevent optimization uint32_t lfsr = 0x81283723 ; uint32_t bit = 0x00000000 ; WDTCTL = WDTPW | WDTHOLD ; // Stop watchdog timer register_settings_for_TIMER1 (); __bis_SR_register ( GIE ); // Enable CPU Interrupt while ( 1 ){ P1OUT = lfsr & 0xFF ; // toggle P1.0 bit = (( lfsr >> 31 ) ^ ( lfsr >> 21 ) ^ ( lfsr >> 1 ) ^ ( lfsr >> 0 )); lfsr = ( lfsr >> 1 ) | ( bit << 31 ); for ( i = 2500 ; i > 0 ; i -- ); // delay } }","title":"Wireless Power Transfer"},{"location":"wpt/#msp430-project-with-wireless-power-transfer","text":"","title":"MSP430 Project with Wireless Power Transfer"},{"location":"wpt/#objective","text":"A wirelessly powered artwork with warm-white leds and flexible string of leds inside a fish bowl, controlled using a MSP430 microcontroller. Power is transferred wirelessly using two coils, one used for transmitting and other for receiving.","title":"OBJECTIVE"},{"location":"wpt/#block-diagram","text":"","title":"BLOCK DIAGRAM"},{"location":"wpt/#schematic","text":"","title":"SCHEMATIC"},{"location":"wpt/#board-layout","text":"","title":"BOARD LAYOUT"},{"location":"wpt/#completed-pcb-with-candles","text":"","title":"COMPLETED PCB WITH CANDLES"},{"location":"wpt/#code","text":"#include <msp430.h> #include <stdint.h> #define LED BIT1 // LED Strip -> P2.1 #define UP 1 //Increasing Brightness #define DOWN 0 //Decreasing Brightness #define BLINK 2 // For blink of leds /** * @brief * These settings are wrt enabling TIMER1 on Lunchbox **/ void register_settings_for_TIMER1 () { P2DIR |= LED ; // LED -> Output P2SEL |= LED ; // LED -> Select Timer Output TA1CCR0 = 255 ; // Set Timer0 PWM Period TA1CCTL1 = OUTMOD_7 ; // Set TA1.1 Waveform Mode - Clear on Compare, Set on Overflow TA1CCR1 = 0 ; // Set TA1.1 PWM duty cycle TA1CCTL0 = CCIE ; // CCR0 Enable Interrupt TA1CTL = TASSEL_2 + MC_1 ; // Timer Clock -> SMCLK, Mode -> Up } volatile int dir = UP ; volatile int count = 0 ; //for delay between change of dutycycle volatile int count2 = 0 ; //for delay between blinking volatile int count3 = 0 ; //for number of blinks between pwm /*brief entry point for TIMER1_interrupt vector */ #pragma vector = TIMER1_A0_VECTOR __interrupt void Timer_A ( void ){ count ++ ; if ( count > 100 ){ //enter if after 100 interrupts switch ( dir ){ case UP : TA1CCR1 = TA1CCR1 + 1 ; //increment CCR1 if ( TA1CCR1 > TA1CCR0 ){ dir = BLINK ; //change dir to BLINK count2 = 0 ; //initialize count2 count3 = 10 ; //initialize count3 } break ; case BLINK : count2 ++ ; // if(count2>10){ //do not change state of leds till count2 becomes 10 count3 -- ; //decrement no. of blinks if ( count3 > 0 ){ if ( TA1CCR1 == 0 ) TA1CCR1 = 255 ; //full brightness else { TA1CCR1 = 0 ; //zero brightness } } else { TA1CCR1 = 255 ; //full brightness dir = DOWN ; //change dir to decresing brightness } count2 = 0 ; } break ; case DOWN : TA1CCR1 = TA1CCR1 - 1 ; //decrement CCR1 if ( TA1CCR1 == 0 ){ dir = UP ; //change direction to increasing } break ; } count = 0 ; } } //@brief entry point for the code/ void main ( void ) { P1DIR |= 0xFF ; volatile unsigned int i ; // volatile to prevent optimization uint32_t lfsr = 0x81283723 ; uint32_t bit = 0x00000000 ; WDTCTL = WDTPW | WDTHOLD ; // Stop watchdog timer register_settings_for_TIMER1 (); __bis_SR_register ( GIE ); // Enable CPU Interrupt while ( 1 ){ P1OUT = lfsr & 0xFF ; // toggle P1.0 bit = (( lfsr >> 31 ) ^ ( lfsr >> 21 ) ^ ( lfsr >> 1 ) ^ ( lfsr >> 0 )); lfsr = ( lfsr >> 1 ) | ( bit << 31 ); for ( i = 2500 ; i > 0 ; i -- ); // delay } }","title":"CODE"}]}