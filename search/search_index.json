{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"Hearty_attiny10/","text":"ATtiny10 BASED HEARTY OBJECTIVE A wearable electronic heart-shaped pendant based on ATtiny10 that displays interesting patterns using 6 Charlieplexed LEDs . SCHEMATIC LAYOUT COMPLETED PCB","title":"ATtiny10 Based Hearty"},{"location":"Hearty_attiny10/#attiny10-based-hearty","text":"","title":"ATtiny10 BASED HEARTY"},{"location":"Hearty_attiny10/#objective","text":"A wearable electronic heart-shaped pendant based on ATtiny10 that displays interesting patterns using 6 Charlieplexed LEDs .","title":"OBJECTIVE"},{"location":"Hearty_attiny10/#schematic","text":"","title":"SCHEMATIC"},{"location":"Hearty_attiny10/#layout","text":"","title":"LAYOUT"},{"location":"Hearty_attiny10/#completed-pcb","text":"","title":"COMPLETED PCB"},{"location":"wpt/","text":"MSP430 Project with Wireless Power Transfer OBJECTIVE A wirelessly powered artwork with warm-white leds and flexible string of leds inside a fish bowl, controlled using a MSP430 microcontroller. Power is transferred wirelessly using two coils, one used for transmitting and other for receiving. BLOCK DIAGRAM SCHEMATIC BOARD LAYOUT COMPLETED PCB WITH CANDLES CODE #include <msp430.h> #include <stdint.h> #define LED BIT1 // LED Strip -> P2.1 #define UP 1 //Increasing Brightness #define DOWN 0 //Decreasing Brightness #define BLINK 2 // For blink of leds /** * @brief * These settings are wrt enabling TIMER1 on Lunchbox **/ void register_settings_for_TIMER1 () { P2DIR |= LED ; // LED -> Output P2SEL |= LED ; // LED -> Select Timer Output TA1CCR0 = 255 ; // Set Timer0 PWM Period TA1CCTL1 = OUTMOD_7 ; // Set TA1.1 Waveform Mode - Clear on Compare, Set on Overflow TA1CCR1 = 0 ; // Set TA1.1 PWM duty cycle TA1CCTL0 = CCIE ; // CCR0 Enable Interrupt TA1CTL = TASSEL_2 + MC_1 ; // Timer Clock -> SMCLK, Mode -> Up } volatile int dir = UP ; volatile int count = 0 ; //for delay between change of dutycycle volatile int count2 = 0 ; //for delay between blinking volatile int count3 = 0 ; //for number of blinks between pwm /*brief entry point for TIMER1_interrupt vector */ #pragma vector = TIMER1_A0_VECTOR __interrupt void Timer_A ( void ){ count ++ ; if ( count > 100 ){ //enter if after 100 interrupts switch ( dir ){ case UP : TA1CCR1 = TA1CCR1 + 1 ; //increment CCR1 if ( TA1CCR1 > TA1CCR0 ){ dir = BLINK ; //change dir to BLINK count2 = 0 ; //initialize count2 count3 = 10 ; //initialize count3 } break ; case BLINK : count2 ++ ; // if(count2>10){ //do not change state of leds till count2 becomes 10 count3 -- ; //decrement no. of blinks if ( count3 > 0 ){ if ( TA1CCR1 == 0 ) TA1CCR1 = 255 ; //full brightness else { TA1CCR1 = 0 ; //zero brightness } } else { TA1CCR1 = 255 ; //full brightness dir = DOWN ; //change dir to decresing brightness } count2 = 0 ; } break ; case DOWN : TA1CCR1 = TA1CCR1 - 1 ; //decrement CCR1 if ( TA1CCR1 == 0 ){ dir = UP ; //change direction to increasing } break ; } count = 0 ; } } //@brief entry point for the code/ void main ( void ) { P1DIR |= 0xFF ; volatile unsigned int i ; // volatile to prevent optimization uint32_t lfsr = 0x81283723 ; uint32_t bit = 0x00000000 ; WDTCTL = WDTPW | WDTHOLD ; // Stop watchdog timer register_settings_for_TIMER1 (); __bis_SR_register ( GIE ); // Enable CPU Interrupt while ( 1 ){ P1OUT = lfsr & 0xFF ; // toggle P1.0 bit = (( lfsr >> 31 ) ^ ( lfsr >> 21 ) ^ ( lfsr >> 1 ) ^ ( lfsr >> 0 )); lfsr = ( lfsr >> 1 ) | ( bit << 31 ); for ( i = 2500 ; i > 0 ; i -- ); // delay } }","title":"Wireless Power Transfer"},{"location":"wpt/#msp430-project-with-wireless-power-transfer","text":"","title":"MSP430 Project with Wireless Power Transfer"},{"location":"wpt/#objective","text":"A wirelessly powered artwork with warm-white leds and flexible string of leds inside a fish bowl, controlled using a MSP430 microcontroller. Power is transferred wirelessly using two coils, one used for transmitting and other for receiving.","title":"OBJECTIVE"},{"location":"wpt/#block-diagram","text":"","title":"BLOCK DIAGRAM"},{"location":"wpt/#schematic","text":"","title":"SCHEMATIC"},{"location":"wpt/#board-layout","text":"","title":"BOARD LAYOUT"},{"location":"wpt/#completed-pcb-with-candles","text":"","title":"COMPLETED PCB WITH CANDLES"},{"location":"wpt/#code","text":"#include <msp430.h> #include <stdint.h> #define LED BIT1 // LED Strip -> P2.1 #define UP 1 //Increasing Brightness #define DOWN 0 //Decreasing Brightness #define BLINK 2 // For blink of leds /** * @brief * These settings are wrt enabling TIMER1 on Lunchbox **/ void register_settings_for_TIMER1 () { P2DIR |= LED ; // LED -> Output P2SEL |= LED ; // LED -> Select Timer Output TA1CCR0 = 255 ; // Set Timer0 PWM Period TA1CCTL1 = OUTMOD_7 ; // Set TA1.1 Waveform Mode - Clear on Compare, Set on Overflow TA1CCR1 = 0 ; // Set TA1.1 PWM duty cycle TA1CCTL0 = CCIE ; // CCR0 Enable Interrupt TA1CTL = TASSEL_2 + MC_1 ; // Timer Clock -> SMCLK, Mode -> Up } volatile int dir = UP ; volatile int count = 0 ; //for delay between change of dutycycle volatile int count2 = 0 ; //for delay between blinking volatile int count3 = 0 ; //for number of blinks between pwm /*brief entry point for TIMER1_interrupt vector */ #pragma vector = TIMER1_A0_VECTOR __interrupt void Timer_A ( void ){ count ++ ; if ( count > 100 ){ //enter if after 100 interrupts switch ( dir ){ case UP : TA1CCR1 = TA1CCR1 + 1 ; //increment CCR1 if ( TA1CCR1 > TA1CCR0 ){ dir = BLINK ; //change dir to BLINK count2 = 0 ; //initialize count2 count3 = 10 ; //initialize count3 } break ; case BLINK : count2 ++ ; // if(count2>10){ //do not change state of leds till count2 becomes 10 count3 -- ; //decrement no. of blinks if ( count3 > 0 ){ if ( TA1CCR1 == 0 ) TA1CCR1 = 255 ; //full brightness else { TA1CCR1 = 0 ; //zero brightness } } else { TA1CCR1 = 255 ; //full brightness dir = DOWN ; //change dir to decresing brightness } count2 = 0 ; } break ; case DOWN : TA1CCR1 = TA1CCR1 - 1 ; //decrement CCR1 if ( TA1CCR1 == 0 ){ dir = UP ; //change direction to increasing } break ; } count = 0 ; } } //@brief entry point for the code/ void main ( void ) { P1DIR |= 0xFF ; volatile unsigned int i ; // volatile to prevent optimization uint32_t lfsr = 0x81283723 ; uint32_t bit = 0x00000000 ; WDTCTL = WDTPW | WDTHOLD ; // Stop watchdog timer register_settings_for_TIMER1 (); __bis_SR_register ( GIE ); // Enable CPU Interrupt while ( 1 ){ P1OUT = lfsr & 0xFF ; // toggle P1.0 bit = (( lfsr >> 31 ) ^ ( lfsr >> 21 ) ^ ( lfsr >> 1 ) ^ ( lfsr >> 0 )); lfsr = ( lfsr >> 1 ) | ( bit << 31 ); for ( i = 2500 ; i > 0 ; i -- ); // delay } }","title":"CODE"}]}