{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"Hearty_attiny10/","text":"ATtiny10 BASED HEARTY OBJECTIVE A wearable electronic heart-shaped pendant based on ATtiny10 that displays interesting patterns using 6 Charlieplexed LEDs . SCHEMATIC LAYOUT COMPLETED PCB CODE /* * hearty_attiny10.cpp * * Created: 19-01-2020 20:13:13 * Author : Naman */ # define F_CPU 1000000UL #include <avr/io.h> #include <util/delay.h> #include <avr/interrupt.h> void LED1 (), LED2 (), LED3 (), LED4 (), LED5 (), LED6 (); void alternate_led (); void all_blink (); void two_to_full (); void off_moving (); void half_blink (); void one_by_one (); int main ( void ) { /* Replace with your application code */ while ( 1 ) { alternate_led (); _delay_ms ( 50 ); all_blink (); off_moving (); half_blink (); one_by_one (); } } void LED1 () { DDRB |= 0b00000011 ; /* PB0 and PB1 as output */ DDRB &= 0b11111011 ; /* PB2 as input */ PORTB |= 0b00000001 ; /* PB0 high */ PORTB &= 0b11111101 ; /* PB1 low */ } void LED2 () { DDRB |= 0b00000110 ; /* PB0 and PB1 as output */ DDRB &= 0b11111110 ; /* PB2 as input */ PORTB |= 0b00000100 ; /* PB2 high */ PORTB &= 0b11111101 ; /* PB1 low */ } void LED3 () { DDRB |= 0b00000101 ; /* PB0 and PB2 as output */ DDRB &= 0b11111101 ; /* PB1 as input */ PORTB |= 0b00000001 ; /* PB0 high */ PORTB &= 0b11111011 ; /* PB2 low */ } void LED4 () { DDRB |= 0b00000011 ; /* PB1 and PB0 as output */ DDRB &= 0b11111011 ; /* PB2 as input */ PORTB |= 0b00000010 ; /* PB1 high */ PORTB &= 0b11111110 ; /* PB0 low */ } void LED5 () { DDRB |= 0b00000110 ; /* PB1 and PB2 as output */ DDRB &= 0b11111110 ; /* PB0 as input */ PORTB |= 0b00000010 ; /* PB1 high */ PORTB &= 0b11111011 ; /* PB2 low */ } void LED6 () { DDRB |= 0b00000101 ; /* PB0 and PB2 as output */ DDRB &= 0b11111101 ; /* PB1 as input */ PORTB |= 0b00000100 ; /* PB2 high */ PORTB &= 0b11111110 ; /* PB0 low */ } void alternate_led () { for ( int z = 0 ; z < 5 ; z ++ ) { for ( int j = 0 ; j < 5000 ; j ++ ) { LED1 (), LED3 (), LED5 (); } for ( int k = 0 ; k < 5000 ; k ++ ) { LED2 (), LED4 (), LED6 (); } } } void all_blink () { for ( int z = 0 ; z < 5 ; z ++ ) { for ( int i = 0 ; i < 5000 ; i ++ ) { LED1 (), LED2 (), LED3 (), LED4 (), LED5 (), LED6 (); } DDRB &= 0b11111000 ; /* ALL LEDS OFF*/ _delay_ms ( 100 ); } } void off_moving () { for ( int k = 0 ; k < 5 ; k ++ ) { int z = 1000 ; for ( int i = 0 ; i < z ; i ++ ) { LED2 (), LED3 (), LED4 (), LED5 (), LED6 (); } for ( int j = 0 ; j < z ; j ++ ) { LED1 (), LED3 (), LED4 (), LED5 (), LED6 (); } for ( int k = 0 ; k < z ; k ++ ) { LED1 (), LED2 (), LED4 (), LED5 (), LED6 (); } for ( int l = 0 ; l < z ; l ++ ) { LED1 (), LED2 (), LED3 (), LED5 (), LED6 (); } for ( int m = 0 ; m < z ; m ++ ) { LED1 (), LED2 (), LED3 (), LED4 (), LED6 (); } for ( int n = 0 ; n < z ; n ++ ) { LED1 (), LED2 (), LED3 (), LED4 (), LED5 (); } } } void half_blink () { for ( int k = 0 ; k < 10 ; k ++ ) { int z = 2000 ; for ( int i = 0 ; i < z ; i ++ ) { LED1 (), LED2 (), LED3 (); } for ( int j = 0 ; j < z ; j ++ ) { LED4 (), LED5 (), LED6 (); } } } void one_by_one () { for ( int k = 0 ; k < 2 ; k ++ ) { //int z = 6000; for ( int q = 0 ; q < 6000 ; q ++ ) { DDRB &= 0b11111000 ; /* ALL LEDS OFF*/ } for ( int i = 0 ; i < 12000 ; i ++ ) { LED1 (); } for ( int j = 0 ; j < 6000 ; j ++ ) { LED1 (), LED2 (); } for ( int k = 0 ; k < 4000 ; k ++ ) { LED1 (), LED2 (), LED3 (); } for ( int l = 0 ; l < 3000 ; l ++ ) { LED1 (), LED2 (), LED3 (), LED4 (); } for ( int m = 0 ; m < 2400 ; m ++ ) { LED1 (), LED2 (), LED3 (), LED4 (), LED5 (); } for ( int n = 0 ; n < 2000 ; n ++ ) { LED1 (), LED2 (), LED3 (), LED4 (), LED5 (), LED6 (); } for ( int i = 0 ; i < 5 ; i ++ ) { DDRB &= 0b11111000 ; /* ALL LEDS OFF*/ _delay_ms ( 100 ); for ( int p = 0 ; p < 500 ; p ++ ) { LED1 (), LED2 (), LED3 (), LED4 (), LED5 (), LED6 (); } //_delay_ms(100); } } }","title":"ATtiny10 Based Hearty"},{"location":"Hearty_attiny10/#attiny10-based-hearty","text":"","title":"ATtiny10 BASED HEARTY"},{"location":"Hearty_attiny10/#objective","text":"A wearable electronic heart-shaped pendant based on ATtiny10 that displays interesting patterns using 6 Charlieplexed LEDs .","title":"OBJECTIVE"},{"location":"Hearty_attiny10/#schematic","text":"","title":"SCHEMATIC"},{"location":"Hearty_attiny10/#layout","text":"","title":"LAYOUT"},{"location":"Hearty_attiny10/#completed-pcb","text":"","title":"COMPLETED PCB"},{"location":"Hearty_attiny10/#code","text":"/* * hearty_attiny10.cpp * * Created: 19-01-2020 20:13:13 * Author : Naman */ # define F_CPU 1000000UL #include <avr/io.h> #include <util/delay.h> #include <avr/interrupt.h> void LED1 (), LED2 (), LED3 (), LED4 (), LED5 (), LED6 (); void alternate_led (); void all_blink (); void two_to_full (); void off_moving (); void half_blink (); void one_by_one (); int main ( void ) { /* Replace with your application code */ while ( 1 ) { alternate_led (); _delay_ms ( 50 ); all_blink (); off_moving (); half_blink (); one_by_one (); } } void LED1 () { DDRB |= 0b00000011 ; /* PB0 and PB1 as output */ DDRB &= 0b11111011 ; /* PB2 as input */ PORTB |= 0b00000001 ; /* PB0 high */ PORTB &= 0b11111101 ; /* PB1 low */ } void LED2 () { DDRB |= 0b00000110 ; /* PB0 and PB1 as output */ DDRB &= 0b11111110 ; /* PB2 as input */ PORTB |= 0b00000100 ; /* PB2 high */ PORTB &= 0b11111101 ; /* PB1 low */ } void LED3 () { DDRB |= 0b00000101 ; /* PB0 and PB2 as output */ DDRB &= 0b11111101 ; /* PB1 as input */ PORTB |= 0b00000001 ; /* PB0 high */ PORTB &= 0b11111011 ; /* PB2 low */ } void LED4 () { DDRB |= 0b00000011 ; /* PB1 and PB0 as output */ DDRB &= 0b11111011 ; /* PB2 as input */ PORTB |= 0b00000010 ; /* PB1 high */ PORTB &= 0b11111110 ; /* PB0 low */ } void LED5 () { DDRB |= 0b00000110 ; /* PB1 and PB2 as output */ DDRB &= 0b11111110 ; /* PB0 as input */ PORTB |= 0b00000010 ; /* PB1 high */ PORTB &= 0b11111011 ; /* PB2 low */ } void LED6 () { DDRB |= 0b00000101 ; /* PB0 and PB2 as output */ DDRB &= 0b11111101 ; /* PB1 as input */ PORTB |= 0b00000100 ; /* PB2 high */ PORTB &= 0b11111110 ; /* PB0 low */ } void alternate_led () { for ( int z = 0 ; z < 5 ; z ++ ) { for ( int j = 0 ; j < 5000 ; j ++ ) { LED1 (), LED3 (), LED5 (); } for ( int k = 0 ; k < 5000 ; k ++ ) { LED2 (), LED4 (), LED6 (); } } } void all_blink () { for ( int z = 0 ; z < 5 ; z ++ ) { for ( int i = 0 ; i < 5000 ; i ++ ) { LED1 (), LED2 (), LED3 (), LED4 (), LED5 (), LED6 (); } DDRB &= 0b11111000 ; /* ALL LEDS OFF*/ _delay_ms ( 100 ); } } void off_moving () { for ( int k = 0 ; k < 5 ; k ++ ) { int z = 1000 ; for ( int i = 0 ; i < z ; i ++ ) { LED2 (), LED3 (), LED4 (), LED5 (), LED6 (); } for ( int j = 0 ; j < z ; j ++ ) { LED1 (), LED3 (), LED4 (), LED5 (), LED6 (); } for ( int k = 0 ; k < z ; k ++ ) { LED1 (), LED2 (), LED4 (), LED5 (), LED6 (); } for ( int l = 0 ; l < z ; l ++ ) { LED1 (), LED2 (), LED3 (), LED5 (), LED6 (); } for ( int m = 0 ; m < z ; m ++ ) { LED1 (), LED2 (), LED3 (), LED4 (), LED6 (); } for ( int n = 0 ; n < z ; n ++ ) { LED1 (), LED2 (), LED3 (), LED4 (), LED5 (); } } } void half_blink () { for ( int k = 0 ; k < 10 ; k ++ ) { int z = 2000 ; for ( int i = 0 ; i < z ; i ++ ) { LED1 (), LED2 (), LED3 (); } for ( int j = 0 ; j < z ; j ++ ) { LED4 (), LED5 (), LED6 (); } } } void one_by_one () { for ( int k = 0 ; k < 2 ; k ++ ) { //int z = 6000; for ( int q = 0 ; q < 6000 ; q ++ ) { DDRB &= 0b11111000 ; /* ALL LEDS OFF*/ } for ( int i = 0 ; i < 12000 ; i ++ ) { LED1 (); } for ( int j = 0 ; j < 6000 ; j ++ ) { LED1 (), LED2 (); } for ( int k = 0 ; k < 4000 ; k ++ ) { LED1 (), LED2 (), LED3 (); } for ( int l = 0 ; l < 3000 ; l ++ ) { LED1 (), LED2 (), LED3 (), LED4 (); } for ( int m = 0 ; m < 2400 ; m ++ ) { LED1 (), LED2 (), LED3 (), LED4 (), LED5 (); } for ( int n = 0 ; n < 2000 ; n ++ ) { LED1 (), LED2 (), LED3 (), LED4 (), LED5 (), LED6 (); } for ( int i = 0 ; i < 5 ; i ++ ) { DDRB &= 0b11111000 ; /* ALL LEDS OFF*/ _delay_ms ( 100 ); for ( int p = 0 ; p < 500 ; p ++ ) { LED1 (), LED2 (), LED3 (), LED4 (), LED5 (), LED6 (); } //_delay_ms(100); } } }","title":"CODE"},{"location":"boost_tiny45/","text":"BATTERY LEVEL MONITORING AND BOOST BASED ON ATtiny45 OBJECTIVE A boost converter along with auto power cut-off, with an indication for low battery is implemented using ATtiny45 microcontroller. The project was developed to help visually impaired students for carrying out science based optical bench experiments. SCHEMATIC LAYOUT COMPLETED PCB FULLY-CASED ...to be updated CODE #define feedback A3 #define btfd A1 #define buzzer 1 #define F_CPU 8000000UL #include <avr/io.h> #include <util/delay.h> #define max_pwm 128 // #define reqVol 930*0.25 //0.35V #define reqbattery 688 float reading = 0 ; float bttryvol = 0 ; void setup () { // put your setup code here, to run once: DDRB |= 0x01 ; //PB0 as output TCCR1 = ( 1 << CTC1 ) | ( 1 << PWM1A ) | ( 1 << COM1A0 ) | ( 1 << CS10 ); TCCR1 &= ~ (( 1 << CS13 ) | ( 1 << CS12 ) | ( 1 << CS11 ) | ( 1 << COM1A1 )); OCR1C = 0xFF ; //top = 255; OCR1A = 231 ; analogReference ( INTERNAL1V1 ); pinMode ( feedback , INPUT ); pinMode ( btfd , INPUT ); } void loop () { // put your main code here, to run repeatedly: bttryvol = 0 ; reading = 0 ; for ( int i = 1 ; i <= 256 ; i ++ ){ reading += analogRead ( feedback ); } reading /= 256 ; for ( int i = 1 ; i <= 256 ; i ++ ){ bttryvol += analogRead ( btfd ); } bttryvol /= 256 ; if ( bttryvol < reqbattery ){ TCCR1 &= ~ (( 1 << CS13 ) | ( 1 << CS12 ) | ( 1 << CS11 ) | ( 1 << CS10 ) | ( 1 << PWM1A ) | ( 1 << COM1A0 ) | ( 1 << COM1A1 )); pinMode ( buzzer , OUTPUT ); digitalWrite ( buzzer , HIGH ); _delay_ms ( 1000 ); digitalWrite ( buzzer , LOW ); while ( bttryvol < reqbattery ); } if ( reading < reqVol ){ OCR1A -- ; } if ( reading > reqVol ){ OCR1A ++ ; } if ( OCR1A <= max_pwm ){ OCR1A = max_pwm ; } } REFERENCES https://www.radiolocman.com/shem/schematics.html?di=582885","title":"Boost & Battery Monitoring"},{"location":"boost_tiny45/#battery-level-monitoring-and-boost-based-on-attiny45","text":"","title":"BATTERY LEVEL MONITORING AND BOOST BASED ON ATtiny45"},{"location":"boost_tiny45/#objective","text":"A boost converter along with auto power cut-off, with an indication for low battery is implemented using ATtiny45 microcontroller. The project was developed to help visually impaired students for carrying out science based optical bench experiments.","title":"OBJECTIVE"},{"location":"boost_tiny45/#schematic","text":"","title":"SCHEMATIC"},{"location":"boost_tiny45/#layout","text":"","title":"LAYOUT"},{"location":"boost_tiny45/#completed-pcb","text":"","title":"COMPLETED PCB"},{"location":"boost_tiny45/#fully-cased","text":"...to be updated","title":"FULLY-CASED"},{"location":"boost_tiny45/#code","text":"#define feedback A3 #define btfd A1 #define buzzer 1 #define F_CPU 8000000UL #include <avr/io.h> #include <util/delay.h> #define max_pwm 128 // #define reqVol 930*0.25 //0.35V #define reqbattery 688 float reading = 0 ; float bttryvol = 0 ; void setup () { // put your setup code here, to run once: DDRB |= 0x01 ; //PB0 as output TCCR1 = ( 1 << CTC1 ) | ( 1 << PWM1A ) | ( 1 << COM1A0 ) | ( 1 << CS10 ); TCCR1 &= ~ (( 1 << CS13 ) | ( 1 << CS12 ) | ( 1 << CS11 ) | ( 1 << COM1A1 )); OCR1C = 0xFF ; //top = 255; OCR1A = 231 ; analogReference ( INTERNAL1V1 ); pinMode ( feedback , INPUT ); pinMode ( btfd , INPUT ); } void loop () { // put your main code here, to run repeatedly: bttryvol = 0 ; reading = 0 ; for ( int i = 1 ; i <= 256 ; i ++ ){ reading += analogRead ( feedback ); } reading /= 256 ; for ( int i = 1 ; i <= 256 ; i ++ ){ bttryvol += analogRead ( btfd ); } bttryvol /= 256 ; if ( bttryvol < reqbattery ){ TCCR1 &= ~ (( 1 << CS13 ) | ( 1 << CS12 ) | ( 1 << CS11 ) | ( 1 << CS10 ) | ( 1 << PWM1A ) | ( 1 << COM1A0 ) | ( 1 << COM1A1 )); pinMode ( buzzer , OUTPUT ); digitalWrite ( buzzer , HIGH ); _delay_ms ( 1000 ); digitalWrite ( buzzer , LOW ); while ( bttryvol < reqbattery ); } if ( reading < reqVol ){ OCR1A -- ; } if ( reading > reqVol ){ OCR1A ++ ; } if ( OCR1A <= max_pwm ){ OCR1A = max_pwm ; } }","title":"CODE"},{"location":"boost_tiny45/#references","text":"https://www.radiolocman.com/shem/schematics.html?di=582885","title":"REFERENCES"},{"location":"espydio/","text":"espydio A command line utility built using python to automate audio file conversions, thereby assisting audio playing on ESP32 (primarily for Tactile Tricorder ). Installation This requires that SoX version 14.4.2 or higher is installed with required handlers for MP3 files (path for excecutable file must be added to environment variables). To install the most up-to-date release of this module via PyPi: pip install espydio To install the master branch: pip install git+https://github.com/namanPuri/espydio.git or, Simply clone the git repository and install setup.py. git clone https://github.com/namanPuri/espydio.git cd espydio python setup.py install USAGE Once espydio is installed, open any command-line tool and run : >espydio If everything is good upto here, this must be recognised and you will get this as output. usage: espydio [ -h ] { info,toWav,toHex,tts,stream,allToWav,allToHex,allToMp3,tth } ... espydio: error: the following arguments are required: command i.e., espydio - List of Commands info toWav toHex tts stream allToWav allTohex allToMp3 tth To get a list of commands, in command-line tool itself with short description, you can run >espydio -h Command Descriptions and Examples To get the description of using a particular command you can run: >espydio <name of command> -h It will output the command usage and decription of it's required parameters. 1. info Description: This command can be used to print the details of the given audio file. Usage: espydio info [-h] -n NAME_OF_FILE Example: 2. toWav Description: This command converts the given MP3 or OGG file to WAV format with a sampling rate of 24khz and with sample encoding as 8-bit unsigned-integer PCM. Usage: espydio toWav [-h] -i INPUT_FILE_NAME -o OUTPUT_FILE_NAME Example: Comparing the details of MP3 file and converted Wav file. 3. toHex Description: This command converts the given WAV file to arduino-ide supported C header file containing the hex codes of the samples stored in an array with the required type qualifier to store the array in flash memory of the controller and not in RAM. Usage: espydio toHex [-h] -n WAV_FILE_NAME -a ARRAY_NAME -o HEX_FILE_NAME Example: C header would like this. 4. tts Description: This command converts the given text to speech(MP3 format), with the desired language settings. Usage: espydio tts [-h] -t TEXT -l LANGUAGE -o OUTPUT_MP3_FILE_NAME Example: 5. stream Description: Using this command, you can make a server using python and host any MP3 or WAV files of any duration on it. ESP32 can then be programmed to take the data from the server and play the same. You can verify that the server is created by copying the address appended with page to route, and running that address on any browser on same or some different device provided it should be connected to the same network. Usage: espydio stream [-h] -r PAGE_TO_ROUTE -f FILE_NAME -t FILE_TYPE Example: 6. allToWav Description: This command converts all the MP3 files in the given directory to the corresponding WAV files, and store them in a folder with name WAV files in the working directory. The converted WAV files would have a sampling rate of 24khz and sample encoding as 8-bit unsigned-integer PCM. The name of the converted WAV file will be same as that of the MP3 one. Usage: espydio allToWav [-h] [-i PATH_TO_FOLDER] Example: 7. allToHex Description: This command converts all the WAV files in the given directory to their corresponding hex codes and save them in a C-header file. The C-header file generated would have names of all arrays which it contains, commented in the beginning. Usage: espydio allToHex [-h] [-i PATH_TO_FOLDER] -n HEX_FILE_NAME Example: C-header file would look like this: 8. allToMp3 Description: This command converts the given texts or a range of numbers with the given step size and with specified language settings to speech in Mp3 format. The arguments for text and for numbers are mutually exclusive. The files generated would be stored in a folder with name MP3 files in the working directory. Usage: espydio allToMp3 [-h] (-t TEXT [TEXT ...] | -r ) -l LANGUAGE Example: 9. tth Description: This command converts the given texts or a range of numbers with the given step size and with specified language settings to their corresponding hex codes and save them all in a C-header file. The arguments for text and for numbers are mutually exclusive here too. The hex file generated with the given name will save in the folder with name as Hex file in the working directory. Usage: espydio tth [-h] (-t TEXT [TEXT ...] | -r ) -l LANGUAGE -n HEX_FILE_NAME Example: C-header would look like:","title":"espydio"},{"location":"espydio/#espydio","text":"A command line utility built using python to automate audio file conversions, thereby assisting audio playing on ESP32 (primarily for Tactile Tricorder ).","title":"espydio"},{"location":"espydio/#installation","text":"This requires that SoX version 14.4.2 or higher is installed with required handlers for MP3 files (path for excecutable file must be added to environment variables). To install the most up-to-date release of this module via PyPi: pip install espydio To install the master branch: pip install git+https://github.com/namanPuri/espydio.git or, Simply clone the git repository and install setup.py. git clone https://github.com/namanPuri/espydio.git cd espydio python setup.py install","title":"Installation"},{"location":"espydio/#usage","text":"Once espydio is installed, open any command-line tool and run : >espydio If everything is good upto here, this must be recognised and you will get this as output. usage: espydio [ -h ] { info,toWav,toHex,tts,stream,allToWav,allToHex,allToMp3,tth } ... espydio: error: the following arguments are required: command i.e.,","title":"USAGE"},{"location":"espydio/#espydio-list-of-commands","text":"info toWav toHex tts stream allToWav allTohex allToMp3 tth To get a list of commands, in command-line tool itself with short description, you can run >espydio -h","title":"espydio - List of Commands"},{"location":"espydio/#command-descriptions-and-examples","text":"To get the description of using a particular command you can run: >espydio <name of command> -h It will output the command usage and decription of it's required parameters.","title":"Command Descriptions and Examples"},{"location":"espydio/#1-info","text":"Description: This command can be used to print the details of the given audio file. Usage: espydio info [-h] -n NAME_OF_FILE Example:","title":"1. info "},{"location":"espydio/#2-towav","text":"Description: This command converts the given MP3 or OGG file to WAV format with a sampling rate of 24khz and with sample encoding as 8-bit unsigned-integer PCM. Usage: espydio toWav [-h] -i INPUT_FILE_NAME -o OUTPUT_FILE_NAME Example: Comparing the details of MP3 file and converted Wav file.","title":"2. toWav "},{"location":"espydio/#3-tohex","text":"Description: This command converts the given WAV file to arduino-ide supported C header file containing the hex codes of the samples stored in an array with the required type qualifier to store the array in flash memory of the controller and not in RAM. Usage: espydio toHex [-h] -n WAV_FILE_NAME -a ARRAY_NAME -o HEX_FILE_NAME Example: C header would like this.","title":"3. toHex "},{"location":"espydio/#4-tts","text":"Description: This command converts the given text to speech(MP3 format), with the desired language settings. Usage: espydio tts [-h] -t TEXT -l LANGUAGE -o OUTPUT_MP3_FILE_NAME Example:","title":"4. tts "},{"location":"espydio/#5-stream","text":"Description: Using this command, you can make a server using python and host any MP3 or WAV files of any duration on it. ESP32 can then be programmed to take the data from the server and play the same. You can verify that the server is created by copying the address appended with page to route, and running that address on any browser on same or some different device provided it should be connected to the same network. Usage: espydio stream [-h] -r PAGE_TO_ROUTE -f FILE_NAME -t FILE_TYPE Example:","title":"5. stream "},{"location":"espydio/#6-alltowav","text":"Description: This command converts all the MP3 files in the given directory to the corresponding WAV files, and store them in a folder with name WAV files in the working directory. The converted WAV files would have a sampling rate of 24khz and sample encoding as 8-bit unsigned-integer PCM. The name of the converted WAV file will be same as that of the MP3 one. Usage: espydio allToWav [-h] [-i PATH_TO_FOLDER] Example:","title":"6. allToWav "},{"location":"espydio/#7-alltohex","text":"Description: This command converts all the WAV files in the given directory to their corresponding hex codes and save them in a C-header file. The C-header file generated would have names of all arrays which it contains, commented in the beginning. Usage: espydio allToHex [-h] [-i PATH_TO_FOLDER] -n HEX_FILE_NAME Example: C-header file would look like this:","title":"7. allToHex "},{"location":"espydio/#8-alltomp3","text":"Description: This command converts the given texts or a range of numbers with the given step size and with specified language settings to speech in Mp3 format. The arguments for text and for numbers are mutually exclusive. The files generated would be stored in a folder with name MP3 files in the working directory. Usage: espydio allToMp3 [-h] (-t TEXT [TEXT ...] | -r ) -l LANGUAGE Example:","title":"8. allToMp3 "},{"location":"espydio/#9-tth","text":"Description: This command converts the given texts or a range of numbers with the given step size and with specified language settings to their corresponding hex codes and save them all in a C-header file. The arguments for text and for numbers are mutually exclusive here too. The hex file generated with the given name will save in the folder with name as Hex file in the working directory. Usage: espydio tth [-h] (-t TEXT [TEXT ...] | -r ) -l LANGUAGE -n HEX_FILE_NAME Example: C-header would look like:","title":"9. tth "},{"location":"fpga_based_color_mixer/","text":"FPGA BASED COLOR MIXER","title":"**FPGA BASED COLOR MIXER**"},{"location":"fpga_based_color_mixer/#fpga-based-color-mixer","text":"","title":"FPGA BASED COLOR MIXER"},{"location":"wpt/","text":"MSP430 Project with Wireless Power Transfer OBJECTIVE A wirelessly powered artwork with warm-white leds and flexible string of leds inside a fish bowl, controlled using a MSP430 microcontroller. Power is transferred wirelessly using two coils, one used for transmitting and other for receiving. BLOCK DIAGRAM SCHEMATIC BOARD LAYOUT COMPLETED PCB WITH CANDLES CODE #include <msp430.h> #include <stdint.h> #define LED BIT1 // LED Strip -> P2.1 #define UP 1 //Increasing Brightness #define DOWN 0 //Decreasing Brightness #define BLINK 2 // For blink of leds /** * @brief * These settings are wrt enabling TIMER1 on Lunchbox **/ void register_settings_for_TIMER1 () { P2DIR |= LED ; // LED -> Output P2SEL |= LED ; // LED -> Select Timer Output TA1CCR0 = 255 ; // Set Timer0 PWM Period TA1CCTL1 = OUTMOD_7 ; // Set TA1.1 Waveform Mode - Clear on Compare, Set on Overflow TA1CCR1 = 0 ; // Set TA1.1 PWM duty cycle TA1CCTL0 = CCIE ; // CCR0 Enable Interrupt TA1CTL = TASSEL_2 + MC_1 ; // Timer Clock -> SMCLK, Mode -> Up } volatile int dir = UP ; volatile int count = 0 ; //for delay between change of dutycycle volatile int count2 = 0 ; //for delay between blinking volatile int count3 = 0 ; //for number of blinks between pwm /*brief entry point for TIMER1_interrupt vector */ #pragma vector = TIMER1_A0_VECTOR __interrupt void Timer_A ( void ){ count ++ ; if ( count > 100 ){ //enter if after 100 interrupts switch ( dir ){ case UP : TA1CCR1 = TA1CCR1 + 1 ; //increment CCR1 if ( TA1CCR1 > TA1CCR0 ){ dir = BLINK ; //change dir to BLINK count2 = 0 ; //initialize count2 count3 = 10 ; //initialize count3 } break ; case BLINK : count2 ++ ; // if(count2>10){ //do not change state of leds till count2 becomes 10 count3 -- ; //decrement no. of blinks if ( count3 > 0 ){ if ( TA1CCR1 == 0 ) TA1CCR1 = 255 ; //full brightness else { TA1CCR1 = 0 ; //zero brightness } } else { TA1CCR1 = 255 ; //full brightness dir = DOWN ; //change dir to decresing brightness } count2 = 0 ; } break ; case DOWN : TA1CCR1 = TA1CCR1 - 1 ; //decrement CCR1 if ( TA1CCR1 == 0 ){ dir = UP ; //change direction to increasing } break ; } count = 0 ; } } //@brief entry point for the code/ void main ( void ) { P1DIR |= 0xFF ; volatile unsigned int i ; // volatile to prevent optimization uint32_t lfsr = 0x81283723 ; uint32_t bit = 0x00000000 ; WDTCTL = WDTPW | WDTHOLD ; // Stop watchdog timer register_settings_for_TIMER1 (); __bis_SR_register ( GIE ); // Enable CPU Interrupt while ( 1 ){ P1OUT = lfsr & 0xFF ; // toggle P1.0 bit = (( lfsr >> 31 ) ^ ( lfsr >> 21 ) ^ ( lfsr >> 1 ) ^ ( lfsr >> 0 )); lfsr = ( lfsr >> 1 ) | ( bit << 31 ); for ( i = 2500 ; i > 0 ; i -- ); // delay } }","title":"Wireless Power Transfer"},{"location":"wpt/#msp430-project-with-wireless-power-transfer","text":"","title":"MSP430 Project with Wireless Power Transfer"},{"location":"wpt/#objective","text":"A wirelessly powered artwork with warm-white leds and flexible string of leds inside a fish bowl, controlled using a MSP430 microcontroller. Power is transferred wirelessly using two coils, one used for transmitting and other for receiving.","title":"OBJECTIVE"},{"location":"wpt/#block-diagram","text":"","title":"BLOCK DIAGRAM"},{"location":"wpt/#schematic","text":"","title":"SCHEMATIC"},{"location":"wpt/#board-layout","text":"","title":"BOARD LAYOUT"},{"location":"wpt/#completed-pcb-with-candles","text":"","title":"COMPLETED PCB WITH CANDLES"},{"location":"wpt/#code","text":"#include <msp430.h> #include <stdint.h> #define LED BIT1 // LED Strip -> P2.1 #define UP 1 //Increasing Brightness #define DOWN 0 //Decreasing Brightness #define BLINK 2 // For blink of leds /** * @brief * These settings are wrt enabling TIMER1 on Lunchbox **/ void register_settings_for_TIMER1 () { P2DIR |= LED ; // LED -> Output P2SEL |= LED ; // LED -> Select Timer Output TA1CCR0 = 255 ; // Set Timer0 PWM Period TA1CCTL1 = OUTMOD_7 ; // Set TA1.1 Waveform Mode - Clear on Compare, Set on Overflow TA1CCR1 = 0 ; // Set TA1.1 PWM duty cycle TA1CCTL0 = CCIE ; // CCR0 Enable Interrupt TA1CTL = TASSEL_2 + MC_1 ; // Timer Clock -> SMCLK, Mode -> Up } volatile int dir = UP ; volatile int count = 0 ; //for delay between change of dutycycle volatile int count2 = 0 ; //for delay between blinking volatile int count3 = 0 ; //for number of blinks between pwm /*brief entry point for TIMER1_interrupt vector */ #pragma vector = TIMER1_A0_VECTOR __interrupt void Timer_A ( void ){ count ++ ; if ( count > 100 ){ //enter if after 100 interrupts switch ( dir ){ case UP : TA1CCR1 = TA1CCR1 + 1 ; //increment CCR1 if ( TA1CCR1 > TA1CCR0 ){ dir = BLINK ; //change dir to BLINK count2 = 0 ; //initialize count2 count3 = 10 ; //initialize count3 } break ; case BLINK : count2 ++ ; // if(count2>10){ //do not change state of leds till count2 becomes 10 count3 -- ; //decrement no. of blinks if ( count3 > 0 ){ if ( TA1CCR1 == 0 ) TA1CCR1 = 255 ; //full brightness else { TA1CCR1 = 0 ; //zero brightness } } else { TA1CCR1 = 255 ; //full brightness dir = DOWN ; //change dir to decresing brightness } count2 = 0 ; } break ; case DOWN : TA1CCR1 = TA1CCR1 - 1 ; //decrement CCR1 if ( TA1CCR1 == 0 ){ dir = UP ; //change direction to increasing } break ; } count = 0 ; } } //@brief entry point for the code/ void main ( void ) { P1DIR |= 0xFF ; volatile unsigned int i ; // volatile to prevent optimization uint32_t lfsr = 0x81283723 ; uint32_t bit = 0x00000000 ; WDTCTL = WDTPW | WDTHOLD ; // Stop watchdog timer register_settings_for_TIMER1 (); __bis_SR_register ( GIE ); // Enable CPU Interrupt while ( 1 ){ P1OUT = lfsr & 0xFF ; // toggle P1.0 bit = (( lfsr >> 31 ) ^ ( lfsr >> 21 ) ^ ( lfsr >> 1 ) ^ ( lfsr >> 0 )); lfsr = ( lfsr >> 1 ) | ( bit << 31 ); for ( i = 2500 ; i > 0 ; i -- ); // delay } }","title":"CODE"}]}